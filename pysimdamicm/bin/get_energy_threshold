#!/usr/bin/env python3

import sys
import click

### To avoid ROOT help print out
if not '-h' in sys.argv and not '--help'in sys.argv:
    import numpy as np
    import ROOT
    from array import array

def gaussians(norm0,mu0,sigma0,sigma1,gain,lam_poisson,Xmin,Xmax):

    f0 = ROOT.TF1("G0","[0]*(TMath::Gaus(x/[3],[1]/[3],[2]/[3]) * TMath::Poisson(0,[4]/[3]))",Xmin,Xmax)
    f0.GetHistogram().GetXaxis().SetTitle("pixel charge")
    f0.GetHistogram().GetYaxis().SetTitle("counts")
    f0.SetNpx(1000)
    f0.SetParameters(norm0,mu0,sigma0,gain,lam_poisson)


    f1 = ROOT.TF1("G1","[0]*(TMath::Gaus(x/[3],1+[1]/[3],[2]/[3]) * TMath::Poisson(1,[4]/[3]))",Xmin,Xmax)
    f1.SetNpx(1000)
    f1.SetParameters(norm0,mu0,sigma1,gain,lam_poisson)
    f1.SetLineColor(2)
    f1.SetMarkerColor(1)

    return f0,f1

def scan_params_to_get_Ethr(mu0,gain,sigma_range,lam_range,Xmin,Xmax):

    qmin = mu0
    qmax = gain
    dq = (qmax-qmin)/100.
    norm0 = 1.0

    Nbins = 100
    sig_min, sig_max = sigma_range
    dsig = (sig_max-sig_min)/Nbins
    lam_min, lam_max = lam_range
    dlam = (lam_max-lam_min)/Nbins
    thEcut = ROOT.TH2D("Q_threshold","Q_thresold",Nbins,sig_min,sig_max,Nbins,lam_min,lam_max)
    thEcut_f1 = ROOT.TH2D("Q_threshold_f1","Q_thresold_f1",Nbins,sig_min,sig_max,Nbins,lam_min,lam_max)
    # scan both parameters
    for i,sigma0 in enumerate(np.arange(sig_min,sig_max,dsig)):
        for j,lam_poisson in enumerate(np.arange(lam_min,lam_max,dlam)):
            sigma1 = sigma0
            ## construct gaussians convolved with a poisson
            f0,f1 = gaussians(norm0,mu0,sigma0,sigma1,gain,lam_poisson,Xmin,Xmax)
            ## Get the optimal energy threshold
            qcut,qcut_f1score = get_optimum_threshold(f0,f1,norm0,qmin,qmax,dq,display=False,silent=True)
            
            #print(i,j,qcut,sigma0,lam_poisson)
            _ = thEcut.SetBinContent(i+1,j+1,qcut)
            _ = thEcut_f1.SetBinContent(i+1,j+1,qcut_f1score)
    
    c = ROOT.TCanvas("c","Scan for criteria 1")
    thEcut.SetXTitle("#sigma ")
    thEcut.SetYTitle("#lambda ")
    thEcut.SetNdivisions(20)
    thEcut.Draw("COLZ")
    c.Update()
    c.Draw()

    c2 = ROOT.TCanvas("c2","Scan for criteria 2")
    thEcut_f1.SetXTitle("#sigma ")
    thEcut_f1.SetYTitle("#lambda ")
    thEcut_fq.SetNdivisions(20)
    thEcut_f1.Draw("COLZ")
    c2.Update()
    c2.Draw()

    input("press enter")


    return



def get_optimum_threshold(f0,f1,norm0,qmin,qmax,dq,display=True,silent=False):
    gain = qmax
    x = np.arange(qmin,qmax,dq)

    # criteria 1
    integral_f0 = np.array([ f0.Integral(xi,f0.GetXmax()) for xi in x ])
    integral_f1 = np.array([ f1.Integral(f1.GetXmin(),xi) for xi in x ])
    ratio = integral_f1/integral_f0
    idx = np.argmin(np.abs(ratio-1))
    qcut = np.mean(x[idx:idx+1])
    if not silent:
        print(f"Optimal threshold: {qcut} [ncut for clustering: {np.round(qcut/f0.GetParameter(2),2)}]")
   
    # criteria 2
    precision = np.array([ f1.Integral(xi,f1.GetXmax())/(f1.Integral(xi,f1.GetXmax())+f0.Integral(xi,f0.GetXmax())) for xi in x])
    recall    = np.array([ f1.Integral(xi,f1.GetXmax())/f1.Integral(f1.GetXmin(),f1.GetXmax()) for xi in x])
    f1score   = 2 / (1/recall + 1/precision)
    qcut_f1score = x[np.argmax(f1score)]
    if not silent:
        print(f"Optimal threshold according to F1-score: {qcut_f1score} [ncut for clustering: {np.round(qcut_f1score/f0.GetParameter(2),2)}]")

    if display:
        Ymin = 1e-5
        Ymax = norm0*10

        # plotting
        tline = ROOT.TLine(qcut,Ymin,qcut,Ymax)
        tline.SetLineStyle(9)
        tline.SetLineColor(2)
        tg = ROOT.TGraph(len(x), array('d',x), array('d', ratio))
        tg.SetMinimum(Ymin)
        tg.SetMaximum(Ymax)
        tg.SetMarkerStyle(21)

        c = ROOT.TCanvas("c","Ratio between")
        tg.GetHistogram().GetYaxis().SetTitle("G(1,#sigma)/G(0,#sigma)")
        tg.GetHistogram().GetXaxis().SetTitle("pixel charge")
        tg.Draw("AP")
        tline.Draw("same")
        c.SetLogy()
        c.Update()
        c.Draw()


        c3 = ROOT.TCanvas("c2","F1-score")
        tgF1 = ROOT.TGraph(len(x),array('d',x),array('d',f1score))
        tgF1.SetMarkerStyle(21)
        tgF1.SetMarkerSize(0.8)
        tgF1.GetHistogram().GetYaxis().SetTitle("F1-score")
        tgF1.GetHistogram().GetXaxis().SetTitle("pixel charge ")
        tgF1.Draw("APE")
        pline = ROOT.TLine(qcut_f1score,min(f1score),qcut_f1score,max(f1score))
        pline.SetLineColor(ROOT.kGreen+3)
        pline.Draw("same")
        c3.SetLogy()
        c3.Update()
        c3.Draw()


        c2 = ROOT.TCanvas("c3","PCD distribution with energy threshold")
        leg = ROOT.TLegend(0.45,0.7,0.8,0.8)
        f0.GetHistogram().GetYaxis().SetTitle("counts")
        f0.SetMinimum(Ymin)
        f0.SetMaximum(Ymax)
        f0.GetHistogram().GetXaxis().SetTitle("pxiel charge")
        f0.Draw()
        f1.Draw("same")
        # threshold from ratio of integrals
        qline = ROOT.TLine(qcut,norm0*10,qcut,norm0/100)
        qline.SetLineStyle(9)
        qline.SetLineColor(ROOT.kGreen+1)
        qline.Draw("same")
        leg.AddEntry(qline,f"optimal threshold: {np.round(qcut,4)}","L")
        # threshold from F1-score
        ptline = ROOT.TLine(qcut_f1score,Ymin,qcut_f1score,Ymax)
        ptline.SetLineStyle(10)
        ptline.SetLineColor(ROOT.kBlue+1)
        ptline.Draw("same")
        leg.AddEntry(ptline,f"opt. F1-score: {np.round(qcut_f1score,4)}","L")
        leg.Draw()
        c2.SetLogy()
        c2.Update()
        c2.Draw()
    

        input("press enter")

    return qcut, qcut_f1score


#### F1-score is the harmonic mean of precision and recall:  F1 = 2 / (recall-1 + precision-1)
#### precision is the number of true positive results divided by the number of all samples predicted to be positive, 
####            including those not identified correctly (or POSITIVE PREDICTIVE VALUE)
#### recall is the number of true positive results divided by the number of all samples 
####            that should have been identified as positive (or SENSITIVE)
@click.command(help="Script to get the optimal energy threshold from the harmonic mean of precision and recall")
@click.option("--xrange",help="Energy range of values in units of electrons",type=(float,float),default=(-5.0,5.0))
@click.option("--dcfit",help="Best fit parameters from the DC fit: mu0, sigma0, gain, lam_poisson. Normalization can also be 1.",type=(float,float,float,float),default=(0.003482,0.2729,1.284,0.006609))
@click.option("--scan-sigma",help="Range of sigmas to scan",type=(float,float),default=None)
@click.option("--scan-lam",help="Range of sigmas to scan",type=(float,float),default=None)
def main(xrange,dcfit,scan_sigma,scan_lam):
    
    if scan_sigma is None and scan_lam is None:
        ## energy range for the gaussians, and sets for the Poisson*Gauss functions
        Xmin,Xmax = xrange
        mu0,sigma0,gain,lam_poisson = dcfit
        ## range of values to search for the energy threshold
        qmin = mu0
        qmax = gain
        dq = (qmax-qmin)/100.
        norm0 = 1.0
        sigma1 = sigma0
        ## construct gaussians convolved with a poisson
        f0,f1 = gaussians(norm0,mu0,sigma0,sigma1,gain,lam_poisson,Xmin,Xmax)
        ## Get the optimal energy threshold
        get_optimum_threshold(f0,f1,norm0,qmin,qmax,dq)
    else:
        Xmin,Xmax = xrange
        mu0,sigma0,gain,lam_poisson = dcfit
        scan_params_to_get_Ethr(mu0,gain,scan_sigma,scan_lam,Xmin,Xmax)

    return



########################################################################################
if __name__=='__main__':
    main()

