#!/usr/bin/env python3
import sys
import click

### To avoid ROOT help print out
if not '-h' in sys.argv and not '--help'in sys.argv:
    from dateutil import parser
    from glob import glob
    from array import array
    from astropy.io import fits
    import click
    import numpy as np
    import time
    import ROOT
    
    from scipy.stats.mstats import trimmed_std

@click.command(help="Evolution plot of any variable on the header")
@click.option("-i","--infile", help="List of fits files; A pattern fits file name can also be given")
@click.option("-p","--keypar",help="Keyword of the parameter to build the evolution plot")
@click.option("-e","--keyepar",help="Keyword of the error of the parameter", default=None)
@click.option("--ext",help="Hedader extension ID",default=0)
@click.option("-f","--fitfunc",help="Function name (from ROOT library) to fit the evolution data", default="pol1")
@click.option("--isdc",help="It will normalize the parameter to the total exposure time: PAR / NPBIN/NSBIN/((CTBINEXP+CTBINPIX)/86400)",type=bool,default=True)
@click.option("--std",help="Set to calculate the STD versus as a function of --keypar",type=bool,default=False)
@click.option("--rcols",help="Range of columns to be included",type=(int,int),default=(0,-1))
@click.option("--rrows",help="Range of rows to be included",type=(int,int),default=(0,-1))
@click.option("--sf",help="Calibration factor to convert STD to electron units: (ADU/e)/(SSAMP)",type=float,default=200/(13.3*15.0))
@click.option("--cuttail",help="fraction of the gaussian tail (lower and higher) that should be ignored by trimmed_std",type=float,default=0.1)
@click.option("--xlim",help="Limits for the x-axis", type=(float,float), default=(0,0))
@click.option("--ylim",help="Limits for the y-axis", type=(float,float), default=(0,0))
@click.option("--idimg",help="Set to display sortering id on the x-axis instead of timestamp", type=bool, default=False)
@click.option("--display",help="Set to display sortering id on the x-axis instead of timestamp", type=bool, default=False)
def main(infile,keypar,keyepar,ext,fitfunc,isdc,std,rcols,rrows,sf,cuttail,xlim,ylim,idimg,display):

    _isbatch = ROOT.gROOT.IsBatch()
    ROOT.gROOT.SetBatch(not display)
   
    lof = sorted(list(glob(infile)))   
    # checking if files have been found
    if len(lof)==0:
        raise("IOError: file(s) not found with pattern {}".format(infile))
    
    if std:
        print(sf)
        noise(lof,keypar,ext,rcols,rrows,sf,cuttail)
        return

    par, tstart  = [], []
    if keyepar:
        epar = []
    for fitsfile in lof:
        try:
            # LBC time as timestamp (to sort dataset)
            tstart.append( time.mktime( parser.parse( fits.getval(fitsfile, 'EXPSTART', ext=ext) ).timetuple() ) )
        except KeyError:
            try:
                # MOSKITA
                tstart.append( time.mktime( parser.parse( fits.getval(fitsfile, 'DATESTART', ext=ext) ).timetuple() ) )
            except KeyError:
                # ACM DATA
                tstart.append( time.mktime( parser.parse( fits.getval(fitsfile, 'DATEINI', ext=ext) ).timetuple() ) )

        # value of the keyword and its error
        par.append( float(fits.getval(fitsfile, keypar, ext=ext)) )
        if keyepar:
            epar.append( float(fits.getval(fitsfile, keyepar, ext=ext)) )
        if isdc:
            try:
                cf_texp = 86400.0/(fits.getval(fitsfile,'NPBIN', ext=ext)*fits.getval(fitsfile,'NSBIN',ext=ext)*(fits.getval(fitsfile,'MEXP',ext=ext)+fits.getval(fitsfile,'CTBINPIX',ext=ext)))
                par[-1] = par[-1]*cf_texp
                if keyepar:
                    epar[-1] = epar[-1]*cf_texp
            except KeyError:
                continue
    try:
        if keyepar:
            stime,spar,separ,slof = zip(*sorted(zip(tstart,par,epar,lof)))
        else:
            stime,spar,slof = zip(*sorted(zip(tstart,par,lof)))
    except ValueError:
        stime = tstart
        spar  = par
        if keyepar:
            separ = epar
        slof  = lof
    
    stime = np.array(stime) - np.min(stime)
    if idimg:
        delta_t = stime[1] - stime[0]
        stime = stime / delta_t
    
    # DISPLAY DATA
    if keyepar:
        tg = ROOT.TGraphErrors(len(stime),array('d',stime),array('d',spar),array('d',np.zeros_like(stime)),array('d',epar))
    else:
        tg = ROOT.TGraph(len(stime),array('d',stime),array('d',spar))
    
    if idimg:
        tg.GetHistogram().GetXaxis().SetTitle("relative ID image")
    else:
        tg.GetHistogram().GetXaxis().SetTitle("relative timestamp")
    tg.GetHistogram().GetYaxis().SetTitle(keypar)
    tg.SetMarkerStyle(20)
    tg.SetMarkerSize(0.8)
    tg.SetMarkerColor(1)
    if not xlim[0]==xlim[1]:
        tg.GetHistogram().GetXaxis().SetRangeUser(xlim[0],xlim[1])
    if not ylim[0]==ylim[1]:
        tg.GetHistogram().GetYaxis().SetRangeUser(ylim[0],ylim[1])

    
    # fitfunc
    ff = ROOT.TF1("fitfunc", f"{fitfunc}", min(stime),max(stime))
    ff.SetLineColor(2)
    tg.Fit(ff,"MEQ")

    ROOT.gStyle.SetOptFit(1)
    c = ROOT.TCanvas()
    tg.Draw("A PE")
    c.Update()
    c.SaveAs(f"plot_fitsval_{keypar}_TIMESTAMP.pdf")
    c.SaveAs(f"plot_fitsval_{keypar}_TIMESTAMP.png")


    c2 = ROOT.TCanvas()
    nbins = freedman_bins(spar)
    th = ROOT.TH1D("h","h",nbins,min(spar),max(spar))
    for qi in spar:
        _=th.Fill(qi)
    th.SetTitle(f";{keypar};Counts")
    
    gaus = ROOT.TF1("ffgaus","gaus")
    gaus.SetParameter(0,nbins)
    gaus.SetParameter(1,np.mean(spar))
    gaus.SetParameter(2,np.std(spar))
    gaus.SetLineColor(2)     
    th.Fit(gaus,"MEQ B")
    th.Draw()
    c2.Update()
    
    try:
        stat_box = th.FindObject("stats")
        stat_box.SetX1NDC(0.15)
        stat_box.SetY1NDC(0.63)
        stat_box.SetX2NDC(0.49)
        stat_box.SetY2NDC(0.85)
    except AttributeError:
        pass
    c2.Update()
    c2.SaveAs(f"plot_fitsval_{keypar}_distribution.pdf")
    c2.SaveAs(f"plot_fitsval_{keypar}_distribution.png")
    
    if display:
        c.Draw()
        c2.Draw()
        input("press enter ... ")

    ROOT.gROOT.SetBatch(_isbatch)
    ROOT.gROOT.GetListOfCanvases().Delete()
   
    return


def freedman_bins(data):
    data = np.asarray(data)
    n = len(data)
    iqr = np.subtract(*np.percentile(data, [75, 25]))
    bin_width = 2 * iqr / (n ** (1/3))
    if bin_width == 0:
        return 1  # todos los datos iguales
    bins = int(np.ceil((data.max() - data.min()) / bin_width))
    return max(bins, 1)


def noise(lof,keypar,ext,rcols, rrows, sf, cut_tail=0.1, xsf=15.):
    
    xvalues, yvalues = [],[]
    for fitsfile in sorted(lof):

        xvalues.append( float(fits.getval(fitsfile,keypar,ext=ext)) )

        # calucluate the STD for each image
        data = fits.getdata(fitsfile,ext).astype(float)[rrows[0]:rrows[1],rcols[0]:rcols[1]]
        if sf is not None:
            cal = sf * float(fits.getval(fitsfile,"SSAMP",ext=ext))
        else:
            cal = sf

        yvalues.append( trimmed_std(data.flatten(), cut_tail) / cal )
    
    tg = ROOT.TGraph(len(xvalues),array('d',xvalues),array('d',yvalues))
    
    if keypar in ["PSAMP","SSAMP"]:
        tg = ROOT.TGraph(len(xvalues),array('d',np.array(xvalues)/xsf),array('d',yvalues))
        tg.GetHistogram().GetXaxis().SetTitle(keypar+" [us]")
    else:
        tg = ROOT.TGraph(len(xvalues),array('d',xvalues),array('d',yvalues))
        tg.GetHistogram().GetXaxis().SetTitle(keypar)

    if sf is not None:
        tg.GetHistogram().GetYaxis().SetTitle("STD [w [0.2,0.8] percentile] (e-)")
    else:
        tg.GetHistogram().GetYaxis().SetTitle("STD [w [0.2,0.8] percentile] (ADU)")
    tg.SetMarkerStyle(20)
    tg.SetMarkerSize(0.8)
    tg.SetMarkerColor(1)
    
    ROOT.gROOT.SetBatch(False)
    ROOT.gStyle.SetOptFit(1)
    c = ROOT.TCanvas()
    tg.Draw("A PE")
    c.Update()
    c.Draw()
    input("press enter ... ")
    c.SaveAs(f"plot_fitsval_{keypar}_STD.pdf")

    return


########################################################################################
if __name__=='__main__':
    main()

